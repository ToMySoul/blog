---
title: List
categories: 数据结构
tags: 
- Java
- 数组
---
# List

List在Java 是一个接口，常见的实现类ArrayList和LinkedList

ArrayLsit 底层数据结构是数组；

LinkedList 底层数据结构是链表；

### Java本身就有数组了，为啥用ArrayList

原生的数组会有一个特点拉你在使用的时候必须要为它创建大小，ArrayList不用。

### ArrayList

ArrayList实现了动态扩容

new ArrayList() 的时候，默认会有一个空的Object[] 数组，大小为0.

当我们第一次add添加数据的时候没会给这个数组初始化一个大小，这个大小默认值为10；

使用ArrayList在每一次add的时候，它都会先去计算这个数组够不够空间，如果空间足够，直接追加上去，如果不够就得扩容

###  怎么扩容，一次扩多少 

在源码有个**grow**方法，每一次扩原来的**1.5倍**，比如初始值为10，第十一个元素进来了，发现数组空间不够，所以会扩到15，空间扩完容之后，会调用arraycopy 来对数组进行拷贝。

**ps：扩容的本质：数组拷贝**

### 用的最多的ArrayList

日常遍历的需求比增删要多，往往在尾部添加删除，时间复杂度低，并且增删底层调用的copyof()被优化过；现代CPU堆内存可以块操作；ArrayList的增删不会比LinkedList慢。

### Vector

vector 底层数据结构数组，相对于ArrayList 它是线程安全的，在扩容的时候，它是直接扩容两倍。

**ps: Vector线程安全，扩容原来的两倍**

### 除了Vector 线程安全的List还有哪些？

可以用Collections来讲ArrayList 来包装，编程线程安全，还有一个类CopyOnWriteArrayList;  

copy-on-write 简称cow ,在Linux 系统中所有的进程都是init 进程fork出来的，除了进程号之外，fork 出来的进程，默认和父进程一模一样，当时用了cow 机制；子进程在被fork 之后exec之前，两个进程用的是相同的内存空间；这意味着子进程的代码段、数据的、堆栈都是指向父进程的物理控件；当父子进程有更改的行为发生时，再为子进程分配相应的物理空间。

这与好处就是，等到真正发生修改的时候，才去分配资源，可以减少分配或者复制大量资源时带来的瞬间延时。

简单来说就是懒加载，或者单例模式中的懒汉模式。等真正用到的时候再分配。

在文件系统中也有cow 机制，文件系统cow 就是在修改数据的时候，不会直接在原来的数据位置上进行操作，而是重新找个位置修改，比如要修改数据块A 的内容，先把A读出去，写到B快里面去。如果断电A的内容还在，可以保证数据的完整性。瞬间挂掉了容易恢复。

CopyOnWriteArrayList是一个线程安全的List,底层是通过复制数据的方式来实现的，

### CopyOnWriteArrayList  add（）的实现   

在add方法会加lock 锁，然后会复制一个新的数据，往新的数组里面add真正的元素，然后把array的指向改变为新的数组。

get（）方法又或是size()方法只是获取array 所指向的数组的元素或者大小。 读不加锁，写加锁 

**ps :写时加lock 锁复制数组，替换变量，读不加锁**

### CopyOnWriteArrayList   有什么缺点

很耗费内存，每次set()/add()都会复制一个数组出来，

它只能保证数据的最终一致性，不能保证数据的实时一致性。假设两个线程，一个线程A 读它的数据还没读完。现在线程B把这个List清空了，线程A 此时还是可以把剩余的数据读出来

**ps：只能保证最终一致性，复制数据耗内存**

### 问题点： fork ;init;exec ;Collections;