---
title: Map
categories: 数据结构
tags: 
- Java
- 数组
---
# Map -java1.8

Map在Java 里面是一个接口

常见的实现类：HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap

Map:数据结构 数组+链表

HashMap:数组+链表/红黑树  ;线程不安全

LinkedHashMap底层数据结构：数组+链表/红黑树+双向链表;线程不安全

TreeMap 底层数据结构：红黑树;线程不安全

ConcurrentHashMap底层数据结构 ：数组+链表/红黑树;线程安全

## HashMap

HashMap的大小只能是二次幂；

位运算代替取模（高效）

默认负载因子：0.75

hashMap 允许null 值（key和value都可以），这样key只能有一个，而value可以有多个

### HashMap new一个HashMap 会发生什么；

HashMap有几个构造方法，最主要指定初始值大小和负载因子大小

默认初始化大小16，负载因子大小0.75；HashMap的大小只能那个是2次幂，假设传一个10进去，实际最终HashMap的大小是16，传7最终大小8，具体实现tableSizeFor 可以看到。我们把元素放进HashMap时候需要算出这个元素的所在位置

在HashMap里用的是位运算来代替取模，能够更加高效地算出该元素所在的位置。

 为什么HashMap 的大小只能是2次幂，因为只有大小为2次幂时，才能合理用位运算代替取模。

负载因子大小决定哈希表的扩容和哈希冲突。

默认的HashMap大小为16，负载因子为0.75 意味着数据最多能放12个元素，一旦超过12个元素，则哈希表需要扩容。

16*0.75=12，每次PUT进去的时候都会检查HashMap 的大小有没有超过这个阈值，如果有则需要扩容。

因为HashMap的大小都是2次幂，所以扩容的时候默认是扩原来的2倍。

扩容这个操作肯定是耗时的，那能不能把负载因为调高一点，比如我要调至1，那么我的Hash Map等到16个元素的时候才扩容。

可以，但是负载因子调高了，意味哈希冲突的概率会增高，哈希冲突概率增高，同样会耗时。因为查找的速度变慢了。

### put 元素的时候，传递的key 是怎么算哈希值的？

实现就在hash 方法上，可以发现是，它是先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。

这样做的好处增加了随机性，减少了碰撞冲突的可能性。

 ps:高16位做异或运算（增加随机性）减少哈希冲突概率

### put和get 方法的实现

在put 的时候，首先对key做hash 运算，计算出该key所在的index。

如果没碰撞，直接放到数据中，如果碰撞了，需要判断目前数据结构是链表还是红黑树，根据不同的情况来插入，

假设key 是相同的，则替换到原来的值，最后判断哈希表是否满了（当前哈希表大小*负载因子），如果那满了则扩容

在get的时候，还是对key 做hash 运算，计算出该key所在的index，然后判断是否有hash冲突

假设没有冲突直接返回，假设有冲突则判断当前数据结构是链表还是红黑树，分别从不同的数据结构中取出。

在put元素时 --ps: 

1. 计算hash；
2. 是否发生碰撞（无碰撞直接进数组）（有碰撞判断此时的数据结构）
3. key安全相同时，需要替换
4. 是否需要扩容

### 在HashMap中是怎么判断一个元素是否相同的

首先会比较hash值随后会用==运算符和equals()来判断该元素是否相同。

（如果只有hash值相同，说明该元素哈希冲突了，如果Hash值和equals()|| --都相同，说明元素是同一个）

ps: 对比hash 对比equals 

### HashMap 的数据结构是数组+链表/红黑树？

当数组的大小大于64且链表的大小大于8的时候才会将链表改为红黑树，当红黑树大小为6时，会退化为链表。

这里转红黑树退化为链表的操作主要处于查询和插入时对性能的考量。

链表的插叙时间复杂度o（n），插入时间复杂的o（1），红黑树查询和插入时间复杂度O（logN）

**Ps ：链表-> 红黑树  （数组大小，大于64；链表大 大于8）**

**红黑树->链表 （红黑树大小 小于6）**

### LinkedHashMap

继承了HashMap,在HashMap 的基础上维护了一个双向链表。

有了这个双向链表，我们插入可以是有序的，这里的有序不是指大小有序，而是插入有序。

LinkedHashMap在遍历的时候实际用的是双向链表来遍历的，所以LinkedHashMap的大小不会影响到遍历的性能

**PS：插入有序，继承HashMap 比HashMap多维护一个双向链表**

### TreeMap

TreeMap底层数据结构是红黑树。

TreeMap 的key不能为null（如果为null，那怎么排序），TreeMap有序是通过Comparator来进行比较的，如果comparator为null,那么就使用自然顺序。

**PS：可排序；通过Comparatpr 进行排序**

### ConcurrentHashMap

底层数据结构是数组+链表/红黑树，它能支持高并发的访问和更新，是线程安全的。

通过在部分加锁和利用CAS算法来实现同步，在get 的时候没有加锁，Node 都用了volatile给修饰，

在扩容的时候，会给每个线程分配对于的区间，并且为了防止put Val 导致数据不一致，会给线程的所负责的区间加锁。





**ps:**线程安全的Map  实现类除了ConcurrentHashMap还有一个叫做Hashtable.

当然也可以用Collection来包装出一个线程安全的Map.

无论是HashTable 还是Collection 包装出来的都比较低效（因为都是直接在外层套synchronize ），所以我们一般有线程安全问题考量的都是用ConcurrentHashMap.

#### HashTable 

（key和value 都不允许空值）；

默认11 ，默认加载因子0.75；在构造方法吃石化，每次扩容为原来的2n+1倍



### 问题点：哈希值怎么计算，哈希值是什么，哈希冲突；Comparatpr 排序；链表，红黑树；位运算替代取模？Map实现类HashTable?；Collections？







